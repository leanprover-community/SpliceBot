name: Create single-file PR from review comment (workflow_run)

on:
  workflow_call:
    inputs:
      source_workflow:
        description: 'Name of the source workflow that emitted the bridge artifact'
        required: true
        type: string
      push_to_fork:
        description: 'Optional fork target in owner/repo form for PR branches'
        required: false
        type: string
        default: ''
      maintainer_can_modify:
        description: 'Optional override for maintainer edits on fork PRs ("true" or "false")'
        required: false
        type: string
        default: ''
      token_app_owner:
        description: 'Optional owner used when minting token from a GitHub App installation'
        required: false
        type: string
        default: ''
      branch_token_app_owner:
        description: 'Optional owner used when minting branch_token from a GitHub App installation'
        required: false
        type: string
        default: ''
    secrets:
      token:
        description: 'Token used for artifact download, checkout, and PR API calls (change from GITHUB_TOKEN to allow triggering CI)'
        required: false
      branch_token:
        description: 'Optional token used only to push PR branches (for push_to_fork mode)'
        required: false
      token_app_id:
        description: 'Optional GitHub App ID used to mint token when token is not provided'
        required: false
      token_app_private_key:
        description: 'Optional GitHub App private key used to mint token when token is not provided'
        required: false
      branch_token_app_id:
        description: 'Optional GitHub App ID used to mint branch_token when branch_token is not provided'
        required: false
      branch_token_app_private_key:
        description: 'Optional GitHub App private key used to mint branch_token when branch_token is not provided'
        required: false

permissions:
  actions: read
  contents: write
  pull-requests: write

jobs:
  create-single-file-pr:
    runs-on: ubuntu-latest

    steps:
      - name: Resolve token generation mode
        id: token_mode
        env:
          STATIC_TOKEN: ${{ secrets.token }}
          STATIC_BRANCH_TOKEN: ${{ secrets.branch_token }}
          TOKEN_APP_ID: ${{ secrets.token_app_id }}
          TOKEN_APP_PRIVATE_KEY: ${{ secrets.token_app_private_key }}
          BRANCH_TOKEN_APP_ID: ${{ secrets.branch_token_app_id }}
          BRANCH_TOKEN_APP_PRIVATE_KEY: ${{ secrets.branch_token_app_private_key }}
          PUSH_TO_FORK: ${{ inputs.push_to_fork }}
        run: |
          set -euo pipefail

          mint_token=false
          mint_branch_token=false
          token_source=github.token
          branch_token_source=not-applicable

          if [ -z "${STATIC_TOKEN}" ] && [ -n "${TOKEN_APP_ID}" ] && [ -n "${TOKEN_APP_PRIVATE_KEY}" ]; then
            mint_token=true
          fi

          if [ -n "${PUSH_TO_FORK}" ] && [ -z "${STATIC_BRANCH_TOKEN}" ] && \
             { [ -n "${BRANCH_TOKEN_APP_ID}" ] || [ -n "${TOKEN_APP_ID}" ]; } && \
             { [ -n "${BRANCH_TOKEN_APP_PRIVATE_KEY}" ] || [ -n "${TOKEN_APP_PRIVATE_KEY}" ]; }; then
            mint_branch_token=true
          fi

          if [ -n "${STATIC_TOKEN}" ]; then
            token_source=secrets.token
          elif [ "${mint_token}" = "true" ]; then
            token_source=app-token
          fi

          if [ -n "${PUSH_TO_FORK}" ]; then
            if [ -n "${STATIC_BRANCH_TOKEN}" ]; then
              branch_token_source=secrets.branch_token
            elif [ "${mint_branch_token}" = "true" ]; then
              branch_token_source=app-branch-token
            elif [ -n "${STATIC_TOKEN}" ]; then
              branch_token_source=secrets.token
            elif [ "${mint_token}" = "true" ]; then
              branch_token_source=app-token
            else
              branch_token_source=github.token
            fi
          fi

          echo "mint_token=${mint_token}" >> "$GITHUB_OUTPUT"
          echo "mint_branch_token=${mint_branch_token}" >> "$GITHUB_OUTPUT"
          echo "token_source=${token_source}" >> "$GITHUB_OUTPUT"
          echo "branch_token_source=${branch_token_source}" >> "$GITHUB_OUTPUT"

      - name: Generate token from GitHub App (optional)
        if: steps.token_mode.outputs.mint_token == 'true'
        id: token_from_app
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.token_app_id }}
          private-key: ${{ secrets.token_app_private_key }}
          owner: ${{ inputs.token_app_owner }}

      - name: Generate branch_token from GitHub App (optional)
        if: steps.token_mode.outputs.mint_branch_token == 'true'
        id: branch_token_from_app
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.branch_token_app_id || secrets.token_app_id }}
          private-key: ${{ secrets.branch_token_app_private_key || secrets.token_app_private_key }}
          owner: ${{ inputs.branch_token_app_owner || inputs.token_app_owner }}

      - name: Log token source selection
        run: |
          echo "token source: ${{ steps.token_mode.outputs.token_source }}"
          echo "branch-token source: ${{ steps.token_mode.outputs.branch_token_source }}"

      - name: Consume bridge artifact
        id: bridge
        uses: leanprover-community/privilege-escalation-bridge/consume@v1
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          artifact: workflow-data
          source_workflow: ${{ inputs.source_workflow }}
          require_event: pull_request_review_comment
          fail_on_missing: false
          extract: |
            pr_number=meta.pr_number
            review_comment_id=event.comment.id
            file_path=event.comment.path
            base_ref=outputs.base_ref
            base_repo=event.pull_request.base.repo.full_name
            head_repo=event.pull_request.head.repo.full_name
            head_sha=event.pull_request.head.sha
            head_ref=event.pull_request.head.ref
            head_label=event.pull_request.head.label
            committer=outputs.committer
            author=outputs.author

      - name: Check out BASE (PR base repo @ base_ref)
        if: steps.bridge.outputs.file_path != ''
        id: checkout_base
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          repository: ${{ steps.bridge.outputs.base_repo }}
          ref: ${{ steps.bridge.outputs.base_ref }}
          fetch-depth: 0
          path: base

      - name: Check out HEAD (PR head repo)
        if: steps.bridge.outputs.file_path != ''
        id: checkout_head
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          repository: ${{ steps.bridge.outputs.head_repo }}
          ref: ${{ steps.bridge.outputs.head_sha }}
          fetch-depth: 0
          path: head

      - name: Stage file changes via 3-way patch apply
        if: steps.bridge.outputs.file_path != ''
        id: branch_and_copy
        run: |
          set -euo pipefail

          FILE_PATH="${{ steps.bridge.outputs.file_path }}"
          PR_NUMBER="${{ steps.bridge.outputs.pr_number }}"
          BASE_REF="${{ steps.bridge.outputs.base_ref }}"
          HEAD_SHA="${{ steps.bridge.outputs.head_sha }}"

          # Only keep alphanumeric characters from file name
          SAFE_FILE="$(echo "$FILE_PATH" | sed 's/[^0-9a-zA-Z/._]*//g' | tr -d '\n')"
          BRANCH="splice-bot/file-${SAFE_FILE}-from-PR${PR_NUMBER}"
          printf $'SAFE_FILE: %s\nBRANCH: %s\n' "${SAFE_FILE}" "${BRANCH}"

          echo "BRANCH=$BRANCH" | tee -a "$GITHUB_OUTPUT"

          cd base

          git checkout "${BASE_REF}"

          # Import the PR head commit into this repo object graph so merge-base/diff can run reliably.
          git remote remove splice_head >/dev/null 2>&1 || true
          git remote add splice_head ../head
          git fetch --no-tags splice_head "${HEAD_SHA}"

          HEAD_COMMIT="$(git rev-parse FETCH_HEAD)"
          MERGE_BASE="$(git merge-base "${BASE_REF}" "${HEAD_COMMIT}" || true)"
          if [ -z "${MERGE_BASE}" ]; then
            echo "No merge-base found between ${BASE_REF} and ${HEAD_COMMIT}; cannot build patch."
            echo "APPLY_FAILED=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          PATCH_FILE="../splice-file.patch"
          git diff --binary --no-color "${MERGE_BASE}" "${HEAD_COMMIT}" -- "${FILE_PATH}" > "${PATCH_FILE}"

          if [ ! -s "${PATCH_FILE}" ]; then
            echo "No patch content for ${FILE_PATH} from ${MERGE_BASE}..${HEAD_COMMIT}"
            echo "NO_CHANGES=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          if ! git apply --3way --index "${PATCH_FILE}"; then
            echo "Patch apply failed for ${FILE_PATH}"
            echo "APPLY_FAILED=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          if git diff --cached --quiet; then
            echo "No changes staged for ${FILE_PATH} vs base ${BASE_REF}"
            echo "NO_CHANGES=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

      - name: Create Pull Request
        if: steps.bridge.outputs.file_path != '' && steps.branch_and_copy.outputs.NO_CHANGES != 'true' && steps.branch_and_copy.outputs.APPLY_FAILED != 'true'
        id: cpr
        uses: peter-evans/create-pull-request@98357b18bf14b5342f975ff684046ec3b2a07725 #v8.0.0
        with:
          committer: ${{ steps.bridge.outputs.committer }}
          author: ${{ steps.bridge.outputs.author }}
          path: base
          base: ${{ steps.bridge.outputs.base_ref }}
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          # Fork-only options: when push_to_fork is empty, these resolve to empty strings and CPR uses base-repo branch mode.
          branch-token: ${{ inputs.push_to_fork != '' && (secrets.branch_token || steps.branch_token_from_app.outputs.token || secrets.token || steps.token_from_app.outputs.token || github.token) || '' }}
          push-to-fork: ${{ inputs.push_to_fork != '' && inputs.push_to_fork || '' }}
          # Default to false in fork mode unless explicitly overridden by caller.
          maintainer-can-modify: ${{ inputs.push_to_fork != '' && (inputs.maintainer_can_modify != '' && inputs.maintainer_can_modify || 'false') || '' }}
          commit-message: "Automated addition of changes in ${{ steps.bridge.outputs.file_path }}"
          title: "chore(${{ steps.bridge.outputs.file_path }}): automated extraction"
          body: "This PR was automatically created from a review comment on PR #${{ steps.bridge.outputs.pr_number }}."
          branch: ${{ steps.branch_and_copy.outputs.BRANCH }}
          branch-suffix: random
          delete-branch: true

      - name: Comment back on the original PR
        if: always() && steps.bridge.outputs.pr_number != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const originalPrNumber = Number('${{ steps.bridge.outputs.pr_number }}');
            const reviewCommentId = Number('${{ steps.bridge.outputs.review_comment_id }}');
            const repoFull = '${{ steps.bridge.outputs.base_repo }}';
            const [owner, repo] = repoFull.split('/');
            const filePath = '${{ steps.bridge.outputs.file_path }}';
            const applyFailed = '${{ steps.branch_and_copy.outputs.APPLY_FAILED }}' === 'true';
            const noChanges = '${{ steps.branch_and_copy.outputs.NO_CHANGES }}' === 'true';
            const automatedPrNumber = '${{ steps.cpr.outputs.pull-request-number }}';
            const baseRef = '${{ steps.bridge.outputs.base_ref }}';
            const headRef = '${{ steps.bridge.outputs.head_ref }}';
            const headLabel = '${{ steps.bridge.outputs.head_label }}';
            const sourceBranch = headLabel || headRef;
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}/attempts/${process.env.GITHUB_RUN_ATTEMPT}`;

            if (!Number.isFinite(originalPrNumber) || originalPrNumber <= 0) {
              core.info('Missing or invalid original PR number; cannot post a callback comment.');
              return;
            }

            if (!owner || !repo) {
              core.info(`Missing repository context (${repoFull}); cannot post a callback comment.`);
              return;
            }

            const outcomes = [
              ['Consume bridge artifact', '${{ steps.bridge.outcome }}'],
              ['Check out BASE', '${{ steps.checkout_base.outcome }}'],
              ['Check out HEAD', '${{ steps.checkout_head.outcome }}'],
              ['Stage file changes', '${{ steps.branch_and_copy.outcome }}'],
              ['Create Pull Request', '${{ steps.cpr.outcome }}'],
            ];
            const failedStepNames = outcomes
              .filter(([, outcome]) => outcome === 'failure' || outcome === 'cancelled')
              .map(([name]) => name);
            const outcomeLines = outcomes
              .filter(([, outcome]) => outcome)
              .map(([name, outcome]) => `- ${name}: \`${outcome}\``)
              .join('\n');

            let title = 'Splice bot status';
            let adviceLines = [];
            let bodyIntro = '';

            if (!filePath) {
              title = 'Could not determine target file';
              bodyIntro = 'I could not determine `event.comment.path` from the bridge artifact.';
              adviceLines = [
                'Ensure the source workflow uploaded the `workflow-data` artifact and this run was triggered from a `pull_request_review_comment` event.',
                'Check the run logs link below and re-run after posting a fresh review comment on a file line.',
              ];
            } else if (applyFailed) {
              title = 'Could not apply patch cleanly';
              bodyIntro = `I couldn't cleanly apply the changes for **${filePath}** onto the latest base branch (**${baseRef}**).`;
              adviceLines = [
                `Rebase the source branch (**${sourceBranch}**) onto **${baseRef}**, or merge **${baseRef}** into **${sourceBranch}**.`,
                'Resolve conflicts in that file, push, then trigger the bot again with a new review comment.',
              ];
            } else if (noChanges) {
              title = 'No file changes found';
              bodyIntro = `I found no diff for **${filePath}** between the PR head and merge base, so there was nothing to split into a new PR.`;
              adviceLines = [
                'Confirm the review comment is on a file that actually changed in the current PR head commit range.',
                'Push the intended file changes first, then trigger the bot again with a new review comment.',
              ];
            } else if (automatedPrNumber) {
              title = 'Split PR created';
              bodyIntro = `Split off the changes to **${filePath}** in #${automatedPrNumber}.`;
              adviceLines = [
                `Review and merge #${automatedPrNumber} if it looks correct.`,
              ];
            } else {
              title = 'Failed to create split PR';
              bodyIntro = filePath
                ? `I couldn't create a split PR for **${filePath}**.`
                : "I couldn't create a split PR.";
              adviceLines = [];
              if (failedStepNames.includes('Consume bridge artifact')) {
                adviceLines.push('Ensure the source workflow uploaded `workflow-data` and this workflow is consuming the correct `source_workflow`.');
              }
              if (failedStepNames.includes('Check out BASE') || failedStepNames.includes('Check out HEAD')) {
                adviceLines.push('Verify the token used by checkout can read both base/head repos and that the referenced refs/SHAs still exist.');
              }
              if (failedStepNames.includes('Stage file changes')) {
                adviceLines.push('Inspect the "Stage file changes" logs for git fetch/apply errors and retry after rebasing if needed.');
              }
              if (failedStepNames.includes('Create Pull Request')) {
                adviceLines.push('Verify token permissions include `contents: write` and `pull-requests: write`; in fork mode, ensure branch token can push to the fork.');
              }
              if (adviceLines.length === 0) {
                adviceLines.push('Open the run logs and retry after fixing the reported step failure.');
              }
            }

            const failedStepsLine = failedStepNames.length > 0
              ? `\n\nFailed step(s): ${failedStepNames.join(', ')}.`
              : '';
            const adviceBlock = adviceLines.map((line) => `- ${line}`).join('\n');
            const stepOutcomesDetails = `<details>\n<summary>Step outcomes</summary>\n\n${outcomeLines}\n</details>`;
            const successBody = `**${title}**\n\n${bodyIntro}`;
            const failureBody = `**${title}**\n\n${bodyIntro}${failedStepsLine}\n\nAdvice:\n${adviceBlock}\n\nRun logs: ${runUrl}\n\n${stepOutcomesDetails}`;
            const body = automatedPrNumber ? successBody : failureBody;

            try {
              if (Number.isFinite(reviewCommentId) && reviewCommentId > 0) {
                await github.rest.pulls.createReplyForReviewComment({
                  owner,
                  repo,
                  pull_number: originalPrNumber,
                  comment_id: reviewCommentId,
                  body,
                });
                return;
              }
            } catch (replyError) {
              core.warning(`Unable to reply to review comment ${reviewCommentId}: ${replyError.message}`);
            }

            await github.rest.issues.createComment({ owner, repo, issue_number: originalPrNumber, body });
