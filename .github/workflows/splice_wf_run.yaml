name: Create single-file PR from review comment (workflow_run)

on:
  workflow_call:
    inputs:
      source_workflow:
        description: 'Name of the source workflow that emitted the bridge artifact'
        required: true
        type: string
      push_to_fork:
        description: 'Optional fork target in owner/repo form for PR branches'
        required: false
        type: string
        default: ''
      maintainer_can_modify:
        description: 'Optional override for maintainer edits on fork PRs ("true" or "false")'
        required: false
        type: string
        default: ''
      token_app_owner:
        description: 'Optional owner used when minting token from a GitHub App installation'
        required: false
        type: string
        default: ''
      branch_token_app_owner:
        description: 'Optional owner used when minting branch_token from a GitHub App installation'
        required: false
        type: string
        default: ''
    secrets:
      token:
        description: 'Token used for artifact download, checkout, and PR API calls (change from GITHUB_TOKEN to allow triggering CI)'
        required: false
      branch_token:
        description: 'Optional token used only to push PR branches (for push_to_fork mode)'
        required: false
      token_app_id:
        description: 'Optional GitHub App ID used to mint token when token is not provided'
        required: false
      token_app_private_key:
        description: 'Optional GitHub App private key used to mint token when token is not provided'
        required: false
      branch_token_app_id:
        description: 'Optional GitHub App ID used to mint branch_token when branch_token is not provided'
        required: false
      branch_token_app_private_key:
        description: 'Optional GitHub App private key used to mint branch_token when branch_token is not provided'
        required: false

permissions:
  actions: read
  contents: write
  pull-requests: write

jobs:
  create-single-file-pr:
    runs-on: ubuntu-latest

    steps:
      - name: Resolve token generation mode
        id: token_mode
        env:
          STATIC_TOKEN: ${{ secrets.token }}
          STATIC_BRANCH_TOKEN: ${{ secrets.branch_token }}
          TOKEN_APP_ID: ${{ secrets.token_app_id }}
          TOKEN_APP_PRIVATE_KEY: ${{ secrets.token_app_private_key }}
          BRANCH_TOKEN_APP_ID: ${{ secrets.branch_token_app_id }}
          BRANCH_TOKEN_APP_PRIVATE_KEY: ${{ secrets.branch_token_app_private_key }}
          PUSH_TO_FORK: ${{ inputs.push_to_fork }}
        run: |
          set -euo pipefail

          mint_token=false
          mint_branch_token=false
          token_source=github.token
          branch_token_source=not-applicable

          if [ -z "${STATIC_TOKEN}" ] && [ -n "${TOKEN_APP_ID}" ] && [ -n "${TOKEN_APP_PRIVATE_KEY}" ]; then
            mint_token=true
          fi

          if [ -n "${PUSH_TO_FORK}" ] && [ -z "${STATIC_BRANCH_TOKEN}" ] && \
             { [ -n "${BRANCH_TOKEN_APP_ID}" ] || [ -n "${TOKEN_APP_ID}" ]; } && \
             { [ -n "${BRANCH_TOKEN_APP_PRIVATE_KEY}" ] || [ -n "${TOKEN_APP_PRIVATE_KEY}" ]; }; then
            mint_branch_token=true
          fi

          if [ -n "${STATIC_TOKEN}" ]; then
            token_source=secrets.token
          elif [ "${mint_token}" = "true" ]; then
            token_source=app-token
          fi

          if [ -n "${PUSH_TO_FORK}" ]; then
            if [ -n "${STATIC_BRANCH_TOKEN}" ]; then
              branch_token_source=secrets.branch_token
            elif [ "${mint_branch_token}" = "true" ]; then
              branch_token_source=app-branch-token
            elif [ -n "${STATIC_TOKEN}" ]; then
              branch_token_source=secrets.token
            elif [ "${mint_token}" = "true" ]; then
              branch_token_source=app-token
            else
              branch_token_source=github.token
            fi
          fi

          echo "mint_token=${mint_token}" >> "$GITHUB_OUTPUT"
          echo "mint_branch_token=${mint_branch_token}" >> "$GITHUB_OUTPUT"
          echo "token_source=${token_source}" >> "$GITHUB_OUTPUT"
          echo "branch_token_source=${branch_token_source}" >> "$GITHUB_OUTPUT"

      - name: Generate token from GitHub App (optional)
        if: steps.token_mode.outputs.mint_token == 'true'
        id: token_from_app
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.token_app_id }}
          private-key: ${{ secrets.token_app_private_key }}
          owner: ${{ inputs.token_app_owner }}

      - name: Generate branch_token from GitHub App (optional)
        if: steps.token_mode.outputs.mint_branch_token == 'true'
        id: branch_token_from_app
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.branch_token_app_id || secrets.token_app_id }}
          private-key: ${{ secrets.branch_token_app_private_key || secrets.token_app_private_key }}
          owner: ${{ inputs.branch_token_app_owner || inputs.token_app_owner }}

      - name: Log token source selection
        run: |
          echo "token source: ${{ steps.token_mode.outputs.token_source }}"
          echo "branch-token source: ${{ steps.token_mode.outputs.branch_token_source }}"

      - name: Consume bridge artifact
        id: bridge
        uses: leanprover-community/privilege-escalation-bridge/consume@v1
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          artifact: workflow-data
          source_workflow: ${{ inputs.source_workflow }}
          require_event: pull_request_review_comment
          fail_on_missing: false
          extract: |
            pr_number=meta.pr_number
            review_comment_id=event.comment.id
            file_path=event.comment.path
            base_ref=outputs.base_ref
            base_repo=event.pull_request.base.repo.full_name
            head_repo=event.pull_request.head.repo.full_name
            head_sha=event.pull_request.head.sha
            head_ref=event.pull_request.head.ref
            head_label=event.pull_request.head.label
            committer=outputs.committer
            author=outputs.author

      - name: Check out BASE (PR base repo @ base_ref)
        if: steps.bridge.outputs.file_path != ''
        id: checkout_base
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          repository: ${{ steps.bridge.outputs.base_repo }}
          ref: ${{ steps.bridge.outputs.base_ref }}
          fetch-depth: 0
          path: base

      - name: Check out HEAD (PR head repo)
        if: steps.bridge.outputs.file_path != ''
        id: checkout_head
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          repository: ${{ steps.bridge.outputs.head_repo }}
          ref: ${{ steps.bridge.outputs.head_sha }}
          fetch-depth: 0
          path: head

      - name: Stage file changes via 3-way patch apply
        if: steps.bridge.outputs.file_path != ''
        id: branch_and_copy
        run: |
          set -euo pipefail

          FILE_PATH="${{ steps.bridge.outputs.file_path }}"
          PR_NUMBER="${{ steps.bridge.outputs.pr_number }}"
          BASE_REF="${{ steps.bridge.outputs.base_ref }}"
          HEAD_SHA="${{ steps.bridge.outputs.head_sha }}"

          # Build a bounded, ref-safe slug from the file path.
          FILE_SLUG="$(printf '%s' "${FILE_PATH}" \
            | tr '/[:space:]' '-' \
            | sed -E 's/[^A-Za-z0-9._-]+/-/g; s/\.\.+/./g; s/^[._-]+//; s/[._-]+$//; s/-+/-/g')"
          if [ -z "${FILE_SLUG}" ]; then
            FILE_SLUG="file"
          fi
          FILE_SLUG="${FILE_SLUG:0:80}"
          FILE_HASH="$(printf '%s' "${FILE_PATH}" | sha256sum | cut -c1-10)"
          BRANCH="splice-bot/pr-${PR_NUMBER}-${FILE_SLUG}-${FILE_HASH}"
          printf $'FILE_SLUG: %s\nFILE_HASH: %s\nBRANCH: %s\n' "${FILE_SLUG}" "${FILE_HASH}" "${BRANCH}"

          echo "BRANCH=$BRANCH" | tee -a "$GITHUB_OUTPUT"

          cd base

          git checkout "${BASE_REF}"

          # Import the PR head commit into this repo object graph so merge-base/diff can run reliably.
          git remote remove splice_head >/dev/null 2>&1 || true
          git remote add splice_head ../head
          git fetch --no-tags splice_head "${HEAD_SHA}"

          HEAD_COMMIT="$(git rev-parse FETCH_HEAD)"
          MERGE_BASE="$(git merge-base "${BASE_REF}" "${HEAD_COMMIT}" || true)"
          if [ -z "${MERGE_BASE}" ]; then
            echo "No merge-base found between ${BASE_REF} and ${HEAD_COMMIT}; cannot build patch."
            echo "APPLY_FAILED=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          PATCH_FILE="../splice-file.patch"
          git diff --binary --no-color "${MERGE_BASE}" "${HEAD_COMMIT}" -- "${FILE_PATH}" > "${PATCH_FILE}"

          if [ ! -s "${PATCH_FILE}" ]; then
            echo "No patch content for ${FILE_PATH} from ${MERGE_BASE}..${HEAD_COMMIT}"
            echo "NO_CHANGES=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          if ! git apply --3way --index "${PATCH_FILE}"; then
            echo "Patch apply failed for ${FILE_PATH}"
            echo "APPLY_FAILED=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          if git diff --cached --quiet; then
            echo "No changes staged for ${FILE_PATH} vs base ${BASE_REF}"
            echo "NO_CHANGES=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

      - name: Detect push_to_fork owner type
        if: inputs.push_to_fork != ''
        id: fork_owner
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          script: |
            const pushToFork = '${{ inputs.push_to_fork }}';
            const [forkOwner] = pushToFork.split('/');
            core.setOutput('fork_owner', forkOwner || '');
            if (!forkOwner) {
              core.setOutput('fork_owner_type', 'Unknown');
              return;
            }
            try {
              const { data } = await github.rest.users.getByUsername({ username: forkOwner });
              core.setOutput('fork_owner_type', data.type || 'Unknown');
              core.info(`push_to_fork owner ${forkOwner} type: ${data.type || 'Unknown'}`);
            } catch (error) {
              core.warning(`Unable to resolve push_to_fork owner type for ${forkOwner}: ${error.message}`);
              core.setOutput('fork_owner_type', 'Unknown');
            }

      - name: Validate create-pull-request inputs
        if: steps.bridge.outputs.file_path != '' && steps.branch_and_copy.outputs.NO_CHANGES != 'true' && steps.branch_and_copy.outputs.APPLY_FAILED != 'true'
        id: validate_cpr_inputs
        env:
          PUSH_TO_FORK: ${{ inputs.push_to_fork }}
          MAINTAINER_CAN_MODIFY: ${{ inputs.maintainer_can_modify }}
          BRANCH_NAME: ${{ steps.branch_and_copy.outputs.BRANCH }}
          COMMITTER: ${{ steps.bridge.outputs.committer }}
          AUTHOR: ${{ steps.bridge.outputs.author }}
          BRANCH_TOKEN_SOURCE: ${{ steps.token_mode.outputs.branch_token_source }}
          FORK_OWNER_TYPE: ${{ steps.fork_owner.outputs.fork_owner_type }}
        run: |
          set -euo pipefail

          if [ -n "${PUSH_TO_FORK}" ] && ! [[ "${PUSH_TO_FORK}" =~ ^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$ ]]; then
            echo "::error::Invalid push_to_fork '${PUSH_TO_FORK}'. Expected owner/repo."
            exit 1
          fi

          if [ -n "${PUSH_TO_FORK}" ] && [ "${BRANCH_TOKEN_SOURCE}" = "github.token" ]; then
            echo "::error::push_to_fork is set but branch push token resolved to github.token. Provide branch_token, token, or branch_token_app_* / token_app_* credentials with fork write access."
            exit 1
          fi

          if [ -n "${MAINTAINER_CAN_MODIFY}" ] && [ "${MAINTAINER_CAN_MODIFY}" != "true" ] && [ "${MAINTAINER_CAN_MODIFY}" != "false" ]; then
            echo "::error::Invalid maintainer_can_modify '${MAINTAINER_CAN_MODIFY}'. Expected 'true', 'false', or empty."
            exit 1
          fi

          if [ "${MAINTAINER_CAN_MODIFY}" = "true" ] && [ "${FORK_OWNER_TYPE}" = "Organization" ]; then
            echo "::error::maintainer_can_modify=true is not supported for organization-owned forks. Use a user-owned fork or set maintainer_can_modify to 'false'."
            exit 1
          fi
          if [ "${MAINTAINER_CAN_MODIFY}" = "true" ] && [ -n "${PUSH_TO_FORK}" ] && [ "${FORK_OWNER_TYPE}" = "Unknown" ]; then
            echo "::warning::Could not determine push_to_fork owner type. If this is an organization-owned fork, maintainer_can_modify=true may fail."
          fi

          if ! git check-ref-format --branch "${BRANCH_NAME}" >/dev/null 2>&1; then
            echo "::error::Generated branch name is invalid: '${BRANCH_NAME}'."
            exit 1
          fi

          if [ "${#BRANCH_NAME}" -gt 220 ]; then
            echo "::error::Generated branch name is too long (${#BRANCH_NAME} chars). This indicates a branch generation bug."
            exit 1
          fi

          if [ -n "${COMMITTER}" ] && ! [[ "${COMMITTER}" =~ ^.+ <[^<>[:space:]]+@[^<>[:space:]]+>$ ]]; then
            echo "::error::Invalid committer format '${COMMITTER}'. Expected 'Name <email@address>'."
            exit 1
          fi

          if [ -n "${AUTHOR}" ] && ! [[ "${AUTHOR}" =~ ^.+ <[^<>[:space:]]+@[^<>[:space:]]+>$ ]]; then
            echo "::error::Invalid author format '${AUTHOR}'. Expected 'Name <email@address>'."
            exit 1
          fi

      - name: Create Pull Request
        if: steps.bridge.outputs.file_path != '' && steps.branch_and_copy.outputs.NO_CHANGES != 'true' && steps.branch_and_copy.outputs.APPLY_FAILED != 'true' && steps.validate_cpr_inputs.outcome == 'success'
        id: cpr
        uses: peter-evans/create-pull-request@98357b18bf14b5342f975ff684046ec3b2a07725 #v8.0.0
        with:
          committer: ${{ steps.bridge.outputs.committer }}
          author: ${{ steps.bridge.outputs.author }}
          path: base
          base: ${{ steps.bridge.outputs.base_ref }}
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          # Fork-only options: when push_to_fork is empty, these resolve to empty strings and CPR uses base-repo branch mode.
          branch-token: ${{ inputs.push_to_fork != '' && (secrets.branch_token || steps.branch_token_from_app.outputs.token || secrets.token || steps.token_from_app.outputs.token || github.token) || '' }}
          push-to-fork: ${{ inputs.push_to_fork != '' && inputs.push_to_fork || '' }}
          # CPR expects a strict boolean; treat any non-"true" value as false.
          maintainer-can-modify: ${{ inputs.maintainer_can_modify == 'true' }}
          commit-message: "Automated addition of changes in ${{ steps.bridge.outputs.file_path }}"
          title: "chore(${{ steps.bridge.outputs.file_path }}): automated extraction"
          body: "This PR was automatically created from a review comment on PR #${{ steps.bridge.outputs.pr_number }}."
          branch: ${{ steps.branch_and_copy.outputs.BRANCH }}
          branch-suffix: random
          delete-branch: true

      - name: Comment back on the original PR
        if: always() && steps.bridge.outputs.pr_number != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const originalPrNumber = Number('${{ steps.bridge.outputs.pr_number }}');
            const reviewCommentId = Number('${{ steps.bridge.outputs.review_comment_id }}');
            const repoFull = '${{ steps.bridge.outputs.base_repo }}';
            const [owner, repo] = repoFull.split('/');
            const filePath = '${{ steps.bridge.outputs.file_path }}';
            const applyFailed = '${{ steps.branch_and_copy.outputs.APPLY_FAILED }}' === 'true';
            const noChanges = '${{ steps.branch_and_copy.outputs.NO_CHANGES }}' === 'true';
            const automatedPrNumber = '${{ steps.cpr.outputs.pull-request-number }}';
            const baseRef = '${{ steps.bridge.outputs.base_ref }}';
            const headRef = '${{ steps.bridge.outputs.head_ref }}';
            const headLabel = '${{ steps.bridge.outputs.head_label }}';
            const sourceBranch = headLabel || headRef;
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}/attempts/${process.env.GITHUB_RUN_ATTEMPT}`;
            const tokenSource = '${{ steps.token_mode.outputs.token_source }}';
            const branchTokenSource = '${{ steps.token_mode.outputs.branch_token_source }}';
            const forkOwner = '${{ steps.fork_owner.outputs.fork_owner }}';
            const forkOwnerType = '${{ steps.fork_owner.outputs.fork_owner_type }}';

            if (!Number.isFinite(originalPrNumber) || originalPrNumber <= 0) {
              core.info('Missing or invalid original PR number; cannot post a callback comment.');
              return;
            }

            if (!owner || !repo) {
              core.info(`Missing repository context (${repoFull}); cannot post a callback comment.`);
              return;
            }

            const outcomes = [
              ['Consume bridge artifact', '${{ steps.bridge.outcome }}'],
              ['Check out BASE', '${{ steps.checkout_base.outcome }}'],
              ['Check out HEAD', '${{ steps.checkout_head.outcome }}'],
              ['Stage file changes', '${{ steps.branch_and_copy.outcome }}'],
              ['Detect push_to_fork owner type', '${{ steps.fork_owner.outcome }}'],
              ['Validate create-pull-request inputs', '${{ steps.validate_cpr_inputs.outcome }}'],
              ['Create Pull Request', '${{ steps.cpr.outcome }}'],
            ];
            const failedStepNames = outcomes
              .filter(([, outcome]) => outcome === 'failure' || outcome === 'cancelled')
              .map(([name]) => name);
            const outcomeLines = outcomes
              .filter(([, outcome]) => outcome)
              .map(([name, outcome]) => `- ${name}: \`${outcome}\``)
              .join('\n');

            let title = 'Splice bot status';
            let adviceLines = [];
            let bodyIntro = '';

            if (!filePath) {
              title = 'Could not determine target file';
              bodyIntro = 'I could not determine `event.comment.path` from the bridge artifact.';
              adviceLines = [
                'Ensure the source workflow uploaded the `workflow-data` artifact and this run was triggered from a `pull_request_review_comment` event.',
                'Check the run logs link below and re-run after posting a fresh review comment on a file line.',
              ];
            } else if (applyFailed) {
              title = 'Could not apply patch cleanly';
              bodyIntro = `I couldn't cleanly apply the changes for **${filePath}** onto the latest base branch (**${baseRef}**).`;
              adviceLines = [
                `Rebase the source branch (**${sourceBranch}**) onto **${baseRef}**, or merge **${baseRef}** into **${sourceBranch}**.`,
                'Resolve conflicts in that file, push, then trigger the bot again with a new review comment.',
              ];
            } else if (noChanges) {
              title = 'No file changes found';
              bodyIntro = `I found no diff for **${filePath}** between the PR head and merge base, so there was nothing to split into a new PR.`;
              adviceLines = [
                'Confirm the review comment is on a file that actually changed in the current PR head commit range.',
                'Push the intended file changes first, then trigger the bot again with a new review comment.',
              ];
            } else if (automatedPrNumber) {
              title = 'Split PR created';
              bodyIntro = `Split off the changes to **${filePath}** in #${automatedPrNumber}.`;
              adviceLines = [
                `Review and merge #${automatedPrNumber} if it looks correct.`,
              ];
            } else {
              title = 'Failed to create split PR';
              bodyIntro = filePath
                ? `I couldn't create a split PR for **${filePath}**.`
                : "I couldn't create a split PR.";
              adviceLines = [];
              if (failedStepNames.includes('Consume bridge artifact')) {
                adviceLines.push('Ensure the source workflow uploaded `workflow-data` and this workflow is consuming the correct `source_workflow`.');
              }
              if (failedStepNames.includes('Check out BASE') || failedStepNames.includes('Check out HEAD')) {
                adviceLines.push('Verify the token used by checkout can read both base/head repos and that the referenced refs/SHAs still exist.');
              }
              if (failedStepNames.includes('Stage file changes')) {
                adviceLines.push('Inspect the "Stage file changes" logs for git fetch/apply errors and retry after rebasing if needed.');
              }
              if (failedStepNames.includes('Detect push_to_fork owner type')) {
                adviceLines.push('Verify that `push_to_fork` refers to an existing fork owner and that the workflow token can query repository/user metadata.');
              }
              if (failedStepNames.includes('Validate create-pull-request inputs')) {
                adviceLines.push('Fix invalid `create-pull-request` inputs reported in the validation step logs (for example `push_to_fork`, `maintainer_can_modify`, author/committer format, or generated branch name).');
              }
              if (failedStepNames.includes('Create Pull Request')) {
                adviceLines.push('Check the "Create Pull Request" logs for input validation errors (for example invalid `maintainer-can-modify` values) and other action-level failures.');
                adviceLines.push('Verify fork settings and branch inputs (`push_to_fork`, branch naming, and whether the target branch already exists) are valid for this repository.');
                adviceLines.push('Also verify token permissions include `contents: write` and `pull-requests: write`; in fork mode, ensure branch token can push to the fork.');
              }
              if (adviceLines.length === 0) {
                adviceLines.push('Open the run logs and retry after fixing the reported step failure.');
              }
            }

            const failedStepsLine = failedStepNames.length > 0
              ? `\n\nFailed step(s): ${failedStepNames.join(', ')}.`
              : '';
            const adviceBlock = adviceLines.map((line) => `- ${line}`).join('\n');
            const tokenDiagnostics = [
              `- token source: \`${tokenSource || 'unknown'}\``,
              `- branch token source: \`${branchTokenSource || 'unknown'}\``,
            ];
            if (forkOwner || forkOwnerType) {
              tokenDiagnostics.push(`- push_to_fork owner: \`${forkOwner || 'unknown'}\` (type: \`${forkOwnerType || 'unknown'}\`)`);
            }
            const tokenDiagnosticsBlock = tokenDiagnostics.join('\n');
            const stepOutcomesDetails = `<details>\n<summary>Step outcomes</summary>\n\n${outcomeLines}\n</details>`;
            const successBody = `**${title}**\n\n${bodyIntro}`;
            const failureBody = `**${title}**\n\n${bodyIntro}${failedStepsLine}\n\nAdvice:\n${adviceBlock}\n\nToken diagnostics:\n${tokenDiagnosticsBlock}\n\nRun logs: ${runUrl}\n\n${stepOutcomesDetails}`;
            const body = automatedPrNumber ? successBody : failureBody;

            try {
              if (Number.isFinite(reviewCommentId) && reviewCommentId > 0) {
                await github.rest.pulls.createReplyForReviewComment({
                  owner,
                  repo,
                  pull_number: originalPrNumber,
                  comment_id: reviewCommentId,
                  body,
                });
                return;
              }
            } catch (replyError) {
              core.warning(`Unable to reply to review comment ${reviewCommentId}: ${replyError.message}`);
            }

            await github.rest.issues.createComment({ owner, repo, issue_number: originalPrNumber, body });
