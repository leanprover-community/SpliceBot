name: Create single-file PR from review comment (workflow_run)

on:
  workflow_call:
    inputs:
      source_workflow:
        description: 'Name of the source workflow that emitted the bridge artifact'
        required: true
        type: string
      allow_pr_author:
        description: 'Whether to always allow the PR author to trigger splice-bot'
        required: false
        type: boolean
        default: true
      min_repo_permission:
        description: 'Minimum repo permission allowed to trigger splice-bot (anyone, triage, write)'
        required: false
        type: string
        default: 'anyone'
      allowed_teams:
        description: 'Optional comma/newline-separated team allowlist (team-slug or org/team-slug)'
        required: false
        type: string
        default: ''
      allowed_users:
        description: 'Optional comma/newline-separated GitHub login allowlist'
        required: false
        type: string
        default: ''
      push_to_fork:
        description: 'Optional fork target in owner/repo form for PR branches'
        required: false
        type: string
        default: ''
      maintainer_can_modify:
        description: 'Optional override for maintainer edits on fork PRs ("true" or "false")'
        required: false
        type: string
        default: ''
      token_app_owner:
        description: 'Optional owner used when minting token from a GitHub App installation'
        required: false
        type: string
        default: ''
      branch_token_app_owner:
        description: 'Optional owner used when minting branch_token from a GitHub App installation'
        required: false
        type: string
        default: ''
    secrets:
      token:
        description: 'Token used for artifact download, checkout, and PR API calls (change from GITHUB_TOKEN to allow triggering CI)'
        required: false
      authz_token:
        description: 'Optional token used only for authorization checks (repo permission / team membership)'
        required: false
      branch_token:
        description: 'Optional token used only to push PR branches (for push_to_fork mode)'
        required: false
      token_app_id:
        description: 'Optional GitHub App ID used to mint token when token is not provided'
        required: false
      token_app_private_key:
        description: 'Optional GitHub App private key used to mint token when token is not provided'
        required: false
      branch_token_app_id:
        description: 'Optional GitHub App ID used to mint branch_token when branch_token is not provided'
        required: false
      branch_token_app_private_key:
        description: 'Optional GitHub App private key used to mint branch_token when branch_token is not provided'
        required: false

permissions:
  actions: read
  contents: write
  pull-requests: write

jobs:
  create-single-file-pr:
    runs-on: ubuntu-latest

    steps:
      - name: Resolve token generation mode
        id: token_mode
        env:
          STATIC_TOKEN: ${{ secrets.token }}
          STATIC_BRANCH_TOKEN: ${{ secrets.branch_token }}
          TOKEN_APP_ID: ${{ secrets.token_app_id }}
          TOKEN_APP_PRIVATE_KEY: ${{ secrets.token_app_private_key }}
          BRANCH_TOKEN_APP_ID: ${{ secrets.branch_token_app_id }}
          BRANCH_TOKEN_APP_PRIVATE_KEY: ${{ secrets.branch_token_app_private_key }}
          PUSH_TO_FORK: ${{ inputs.push_to_fork }}
        run: |
          set -euo pipefail

          mint_token=false
          mint_branch_token=false
          token_source=github.token
          branch_token_source=not-applicable

          if [ -z "${STATIC_TOKEN}" ] && [ -n "${TOKEN_APP_ID}" ] && [ -n "${TOKEN_APP_PRIVATE_KEY}" ]; then
            mint_token=true
          fi

          if [ -n "${PUSH_TO_FORK}" ] && [ -z "${STATIC_BRANCH_TOKEN}" ] && \
             { [ -n "${BRANCH_TOKEN_APP_ID}" ] || [ -n "${TOKEN_APP_ID}" ]; } && \
             { [ -n "${BRANCH_TOKEN_APP_PRIVATE_KEY}" ] || [ -n "${TOKEN_APP_PRIVATE_KEY}" ]; }; then
            mint_branch_token=true
          fi

          if [ -n "${STATIC_TOKEN}" ]; then
            token_source=secrets.token
          elif [ "${mint_token}" = "true" ]; then
            token_source=app-token
          fi

          if [ -n "${PUSH_TO_FORK}" ]; then
            if [ -n "${STATIC_BRANCH_TOKEN}" ]; then
              branch_token_source=secrets.branch_token
            elif [ "${mint_branch_token}" = "true" ]; then
              branch_token_source=app-branch-token
            elif [ -n "${STATIC_TOKEN}" ]; then
              branch_token_source=secrets.token
            elif [ "${mint_token}" = "true" ]; then
              branch_token_source=app-token
            else
              branch_token_source=github.token
            fi
          fi

          echo "mint_token=${mint_token}" >> "$GITHUB_OUTPUT"
          echo "mint_branch_token=${mint_branch_token}" >> "$GITHUB_OUTPUT"
          echo "token_source=${token_source}" >> "$GITHUB_OUTPUT"
          echo "branch_token_source=${branch_token_source}" >> "$GITHUB_OUTPUT"

      - name: Generate token from GitHub App (optional)
        if: steps.token_mode.outputs.mint_token == 'true'
        id: token_from_app
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.token_app_id }}
          private-key: ${{ secrets.token_app_private_key }}
          owner: ${{ inputs.token_app_owner }}

      - name: Generate branch_token from GitHub App (optional)
        if: steps.token_mode.outputs.mint_branch_token == 'true'
        id: branch_token_from_app
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.branch_token_app_id || secrets.token_app_id }}
          private-key: ${{ secrets.branch_token_app_private_key || secrets.token_app_private_key }}
          owner: ${{ inputs.branch_token_app_owner || inputs.token_app_owner }}

      - name: Log token source selection
        run: |
          echo "token source: ${{ steps.token_mode.outputs.token_source }}"
          echo "branch-token source: ${{ steps.token_mode.outputs.branch_token_source }}"

      - name: Consume bridge artifact
        id: bridge
        uses: leanprover-community/privilege-escalation-bridge/consume@v1
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          artifact: workflow-data
          source_workflow: ${{ inputs.source_workflow }}
          require_event: pull_request_review_comment
          fail_on_missing: false
          extract: |
            pr_number=meta.pr_number
            review_comment_id=event.comment.id
            file_path=event.comment.path
            commenter_login=event.comment.user.login
            pr_author_login=event.pull_request.user.login
            base_ref=outputs.base_ref
            base_repo=event.pull_request.base.repo.full_name
            head_repo=event.pull_request.head.repo.full_name
            head_sha=event.pull_request.head.sha
            head_ref=event.pull_request.head.ref
            head_label=event.pull_request.head.label
            committer=outputs.committer
            author=outputs.author

      - name: Authorize commenter
        if: steps.bridge.outputs.file_path != ''
        id: authorize_commenter
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          ALLOW_PR_AUTHOR: ${{ inputs.allow_pr_author }}
          MIN_REPO_PERMISSION: ${{ inputs.min_repo_permission }}
          RAW_ALLOWED_TEAMS: ${{ inputs.allowed_teams }}
          RAW_ALLOWED_USERS: ${{ inputs.allowed_users }}
          COMMENTER_LOGIN: ${{ steps.bridge.outputs.commenter_login }}
          PR_AUTHOR_LOGIN: ${{ steps.bridge.outputs.pr_author_login }}
          BASE_REPO: ${{ steps.bridge.outputs.base_repo }}
          AUTHZ_TOKEN_SOURCE: ${{ secrets.authz_token != '' && 'secrets.authz_token' || secrets.token != '' && 'secrets.token' || steps.token_mode.outputs.token_source }}
        with:
          github-token: ${{ secrets.authz_token || secrets.token || steps.token_from_app.outputs.token || github.token }}
          script: |
            const allowPrAuthor = (process.env.ALLOW_PR_AUTHOR || 'true') === 'true';
            const minRepoPermission = (process.env.MIN_REPO_PERMISSION || 'anyone').trim().toLowerCase();
            const commenterLogin = (process.env.COMMENTER_LOGIN || '').trim();
            const prAuthorLogin = (process.env.PR_AUTHOR_LOGIN || '').trim();
            const baseRepo = (process.env.BASE_REPO || '').trim();
            const rawAllowedTeams = process.env.RAW_ALLOWED_TEAMS || '';
            const rawAllowedUsers = process.env.RAW_ALLOWED_USERS || '';
            const authzTokenSource = process.env.AUTHZ_TOKEN_SOURCE || 'unknown';

            const parseList = (raw) =>
              raw
                .split(/[\n,]/)
                .map((item) => item.trim().toLowerCase())
                .filter(Boolean);

            const setAuthzOutputs = (decision, reason, details) => {
              core.setOutput('authz_decision', decision);
              core.setOutput('authz_reason', reason);
              core.setOutput('authz_details', details);
              core.setOutput('authz_token_source', authzTokenSource);
            };

            const deny = (reason, details) => {
              core.warning(`Authorization denied: ${reason}`);
              core.info(details);
              setAuthzOutputs('deny', reason, details);
              core.setFailed(`Authorization denied: ${reason}`);
            };

            const failError = (reason, details) => {
              core.error(`Authorization check error: ${reason}`);
              core.info(details);
              setAuthzOutputs('error', reason, details);
              core.setFailed(`Authorization check error: ${reason}`);
            };

            const allowedTeams = parseList(rawAllowedTeams);
            const allowedUsers = parseList(rawAllowedUsers);
            const validMinPermissions = new Set(['anyone', 'triage', 'write']);
            if (!validMinPermissions.has(minRepoPermission)) {
              failError(
                `Invalid min_repo_permission '${minRepoPermission}'. Expected one of: anyone, triage, write.`,
                [
                  `commenter: ${commenterLogin || '(missing)'}`,
                  `base repo: ${baseRepo || '(missing)'}`,
                ].join('\n')
              );
              return;
            }

            if (!commenterLogin || !prAuthorLogin || !baseRepo) {
              failError(
                'Missing bridge data required for authorization.',
                [
                  `commenter_login: ${commenterLogin || '(missing)'}`,
                  `pr_author_login: ${prAuthorLogin || '(missing)'}`,
                  `base_repo: ${baseRepo || '(missing)'}`,
                  'Ensure splice.yaml emits comment.user.login, pull_request.user.login, and pull_request.base.repo.full_name.',
                ].join('\n')
              );
              return;
            }

            const repoParts = baseRepo.split('/');
            const owner = repoParts[0];
            const repo = repoParts[1];
            if (!owner || !repo || repoParts.length !== 2) {
              failError(`Invalid base repo format '${baseRepo}'. Expected owner/repo.`, `base_repo: ${baseRepo}`);
              return;
            }

            const permissionRank = {
              none: 0,
              read: 1,
              triage: 2,
              write: 3,
              maintain: 4,
              admin: 5,
            };
            const minThreshold = minRepoPermission === 'triage' ? permissionRank.triage : minRepoPermission === 'write' ? permissionRank.write : null;
            let repoPermission = 'not-checked';
            const matchedRules = [];
            const buildDetails = () =>
              [
                `commenter: ${commenterLogin}`,
                `pr author: ${prAuthorLogin}`,
                `base repo: ${baseRepo}`,
                `allow_pr_author: ${allowPrAuthor}`,
                `min_repo_permission: ${minRepoPermission}`,
                `observed_repo_permission: ${repoPermission}`,
                `allowed_users: ${allowedUsers.length > 0 ? allowedUsers.join(', ') : '(none)'}`,
                `allowed_teams: ${allowedTeams.length > 0 ? allowedTeams.join(', ') : '(none)'}`,
                `matched_rules: ${matchedRules.length > 0 ? matchedRules.join(', ') : '(none)'}`,
                `authz token source: ${authzTokenSource}`,
              ].join('\n');
            const authorize = () => {
              const reason = `Authorized ${commenterLogin} via ${matchedRules.join(', ')}.`;
              const details = buildDetails();
              core.info(reason);
              core.info(details);
              setAuthzOutputs('allow', reason, details);
            };

            if (allowPrAuthor && commenterLogin.toLowerCase() === prAuthorLogin.toLowerCase()) {
              matchedRules.push('pr-author');
            }

            if (allowedUsers.includes(commenterLogin.toLowerCase())) {
              matchedRules.push('allowed-users');
            }

            if (matchedRules.length > 0) {
              authorize();
              return;
            }

            if (minRepoPermission === 'anyone') {
              matchedRules.push('repo-permission>=anyone');
              authorize();
              return;
            }

            if (minThreshold !== null) {
              try {
                const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
                  owner,
                  repo,
                  username: commenterLogin,
                });
                repoPermission = (data.permission || 'none').toLowerCase();
              } catch (error) {
                if (error.status === 404) {
                  repoPermission = 'none';
                } else {
                  failError(
                    `Unable to resolve collaborator permission for ${commenterLogin} on ${baseRepo}: ${error.message}`,
                    [
                      `authz token source: ${authzTokenSource}`,
                      'Provide authz_token with sufficient read access if needed.',
                    ].join('\n')
                  );
                  return;
                }
              }

              const observedRank = permissionRank[repoPermission] ?? permissionRank.none;
              if (observedRank >= minThreshold) {
                matchedRules.push(`repo-permission>=${minRepoPermission}`);
                authorize();
                return;
              }
            }

            if (allowedTeams.length > 0) {
              let ownerType = 'Unknown';
              try {
                const { data: repoData } = await github.rest.repos.get({ owner, repo });
                ownerType = repoData.owner?.type || 'Unknown';
              } catch (error) {
                failError(
                  `Unable to resolve repository owner type for ${baseRepo}: ${error.message}`,
                  [
                    `authz token source: ${authzTokenSource}`,
                    'Provide authz_token with repository read access if needed.',
                  ].join('\n')
                );
                return;
              }

              if (ownerType !== 'Organization') {
                deny(
                  `allowed_teams was configured, but ${baseRepo} is not organization-owned.`,
                  [
                    `commenter: ${commenterLogin}`,
                    `base repo owner type: ${ownerType}`,
                    `configured teams: ${allowedTeams.join(', ')}`,
                  ].join('\n')
                );
                return;
              }

              for (const teamSpec of allowedTeams) {
                const parts = teamSpec.split('/');
                const teamOrg = parts.length === 2 ? parts[0] : owner;
                const teamSlug = parts.length === 2 ? parts[1] : teamSpec;
                if (!teamOrg || !teamSlug) {
                  failError(`Invalid team spec '${teamSpec}'. Use team-slug or org/team-slug.`, `configured teams: ${allowedTeams.join(', ')}`);
                  return;
                }

                try {
                  const { data } = await github.rest.teams.getMembershipForUserInOrg({
                    org: teamOrg,
                    team_slug: teamSlug,
                    username: commenterLogin,
                  });
                  if (data.state === 'active') {
                    matchedRules.push(`team:${teamOrg}/${teamSlug}`);
                    authorize();
                    return;
                  }
                } catch (error) {
                  if (error.status === 404) {
                    core.info(`User ${commenterLogin} is not an active member of ${teamOrg}/${teamSlug}.`);
                    continue;
                  }
                  failError(
                    `Unable to verify team membership for ${teamOrg}/${teamSlug}: ${error.message}`,
                    [
                      `authz token source: ${authzTokenSource}`,
                      'Provide authz_token with organization team/membership read permissions if needed.',
                    ].join('\n')
                  );
                  return;
                }
              }
            }

            deny(
              `Commenter ${commenterLogin} is not authorized to trigger splice-bot.`,
              buildDetails()
            );

      - name: Check out BASE (PR base repo @ base_ref)
        if: steps.bridge.outputs.file_path != ''
        id: checkout_base
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          repository: ${{ steps.bridge.outputs.base_repo }}
          ref: ${{ steps.bridge.outputs.base_ref }}
          fetch-depth: 0
          path: base

      - name: Check out HEAD (PR head repo)
        if: steps.bridge.outputs.file_path != ''
        id: checkout_head
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          repository: ${{ steps.bridge.outputs.head_repo }}
          ref: ${{ steps.bridge.outputs.head_sha }}
          fetch-depth: 0
          path: head

      - name: Stage file changes via 3-way patch apply
        if: steps.bridge.outputs.file_path != ''
        id: branch_and_copy
        run: |
          set -euo pipefail

          FILE_PATH="${{ steps.bridge.outputs.file_path }}"
          PR_NUMBER="${{ steps.bridge.outputs.pr_number }}"
          BASE_REF="${{ steps.bridge.outputs.base_ref }}"
          HEAD_SHA="${{ steps.bridge.outputs.head_sha }}"

          # Build a bounded, ref-safe slug from the file path.
          FILE_SLUG="$(printf '%s' "${FILE_PATH}" \
            | tr '/[:space:]' '-' \
            | sed -E 's/[^A-Za-z0-9._-]+/-/g; s/\.\.+/./g; s/^[._-]+//; s/[._-]+$//; s/-+/-/g')"
          if [ -z "${FILE_SLUG}" ]; then
            FILE_SLUG="file"
          fi
          FILE_SLUG="${FILE_SLUG:0:80}"
          FILE_HASH="$(printf '%s' "${FILE_PATH}" | sha256sum | cut -c1-10)"
          BRANCH="splice-bot/pr-${PR_NUMBER}-${FILE_SLUG}-${FILE_HASH}"
          printf $'FILE_SLUG: %s\nFILE_HASH: %s\nBRANCH: %s\n' "${FILE_SLUG}" "${FILE_HASH}" "${BRANCH}"

          echo "BRANCH=$BRANCH" | tee -a "$GITHUB_OUTPUT"

          cd base

          git checkout "${BASE_REF}"

          # Import the PR head commit into this repo object graph so merge-base/diff can run reliably.
          git remote remove splice_head >/dev/null 2>&1 || true
          git remote add splice_head ../head
          git fetch --no-tags splice_head "${HEAD_SHA}"

          HEAD_COMMIT="$(git rev-parse FETCH_HEAD)"
          MERGE_BASE="$(git merge-base "${BASE_REF}" "${HEAD_COMMIT}" || true)"
          if [ -z "${MERGE_BASE}" ]; then
            echo "No merge-base found between ${BASE_REF} and ${HEAD_COMMIT}; cannot build patch."
            echo "APPLY_FAILED=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          PATCH_FILE="../splice-file.patch"
          git diff --binary --no-color "${MERGE_BASE}" "${HEAD_COMMIT}" -- "${FILE_PATH}" > "${PATCH_FILE}"

          if [ ! -s "${PATCH_FILE}" ]; then
            echo "No patch content for ${FILE_PATH} from ${MERGE_BASE}..${HEAD_COMMIT}"
            echo "NO_CHANGES=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          if ! git apply --3way --index "${PATCH_FILE}"; then
            echo "Patch apply failed for ${FILE_PATH}"
            echo "APPLY_FAILED=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

          if git diff --cached --quiet; then
            echo "No changes staged for ${FILE_PATH} vs base ${BASE_REF}"
            echo "NO_CHANGES=true" | tee -a "$GITHUB_OUTPUT"
            exit 0
          fi

      - name: Detect push_to_fork owner type
        if: inputs.push_to_fork != ''
        id: fork_owner
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          script: |
            const pushToFork = '${{ inputs.push_to_fork }}';
            const [forkOwner] = pushToFork.split('/');
            core.setOutput('fork_owner', forkOwner || '');
            if (!forkOwner) {
              core.setOutput('fork_owner_type', 'Unknown');
              return;
            }
            try {
              const { data } = await github.rest.users.getByUsername({ username: forkOwner });
              core.setOutput('fork_owner_type', data.type || 'Unknown');
              core.info(`push_to_fork owner ${forkOwner} type: ${data.type || 'Unknown'}`);
            } catch (error) {
              core.warning(`Unable to resolve push_to_fork owner type for ${forkOwner}: ${error.message}`);
              core.setOutput('fork_owner_type', 'Unknown');
            }

      - name: Validate create-pull-request inputs
        if: steps.bridge.outputs.file_path != '' && steps.authorize_commenter.outcome == 'success' && steps.branch_and_copy.outputs.NO_CHANGES != 'true' && steps.branch_and_copy.outputs.APPLY_FAILED != 'true'
        id: validate_cpr_inputs
        env:
          PUSH_TO_FORK: ${{ inputs.push_to_fork }}
          MAINTAINER_CAN_MODIFY: ${{ inputs.maintainer_can_modify }}
          BRANCH_NAME: ${{ steps.branch_and_copy.outputs.BRANCH }}
          COMMITTER: ${{ steps.bridge.outputs.committer }}
          AUTHOR: ${{ steps.bridge.outputs.author }}
          BRANCH_TOKEN_SOURCE: ${{ steps.token_mode.outputs.branch_token_source }}
          FORK_OWNER_TYPE: ${{ steps.fork_owner.outputs.fork_owner_type }}
        run: |
          set -euo pipefail

          if [ -n "${PUSH_TO_FORK}" ] && ! [[ "${PUSH_TO_FORK}" =~ ^[A-Za-z0-9_.-]+/[A-Za-z0-9_.-]+$ ]]; then
            echo "::error::Invalid push_to_fork '${PUSH_TO_FORK}'. Expected owner/repo."
            exit 1
          fi

          if [ -n "${PUSH_TO_FORK}" ] && [ "${BRANCH_TOKEN_SOURCE}" = "github.token" ]; then
            echo "::error::push_to_fork is set but branch push token resolved to github.token. Provide branch_token, token, or branch_token_app_* / token_app_* credentials with fork write access."
            exit 1
          fi

          if [ -n "${MAINTAINER_CAN_MODIFY}" ] && [ "${MAINTAINER_CAN_MODIFY}" != "true" ] && [ "${MAINTAINER_CAN_MODIFY}" != "false" ]; then
            echo "::error::Invalid maintainer_can_modify '${MAINTAINER_CAN_MODIFY}'. Expected 'true', 'false', or empty."
            exit 1
          fi

          if [ "${MAINTAINER_CAN_MODIFY}" = "true" ] && [ "${FORK_OWNER_TYPE}" = "Organization" ]; then
            echo "::error::maintainer_can_modify=true is not supported for organization-owned forks. Use a user-owned fork or set maintainer_can_modify to 'false'."
            exit 1
          fi
          if [ "${MAINTAINER_CAN_MODIFY}" = "true" ] && [ -n "${PUSH_TO_FORK}" ] && [ "${FORK_OWNER_TYPE}" = "Unknown" ]; then
            echo "::warning::Could not determine push_to_fork owner type. If this is an organization-owned fork, maintainer_can_modify=true may fail."
          fi

          if ! git check-ref-format --branch "${BRANCH_NAME}" >/dev/null 2>&1; then
            echo "::error::Generated branch name is invalid: '${BRANCH_NAME}'."
            exit 1
          fi

          if [ "${#BRANCH_NAME}" -gt 220 ]; then
            echo "::error::Generated branch name is too long (${#BRANCH_NAME} chars). This indicates a branch generation bug."
            exit 1
          fi

          if [ -n "${COMMITTER}" ] && ! [[ "${COMMITTER}" =~ ^.+ <[^<>[:space:]]+@[^<>[:space:]]+>$ ]]; then
            echo "::error::Invalid committer format '${COMMITTER}'. Expected 'Name <email@address>'."
            exit 1
          fi

          if [ -n "${AUTHOR}" ] && ! [[ "${AUTHOR}" =~ ^.+ <[^<>[:space:]]+@[^<>[:space:]]+>$ ]]; then
            echo "::error::Invalid author format '${AUTHOR}'. Expected 'Name <email@address>'."
            exit 1
          fi

      - name: Create Pull Request
        if: steps.bridge.outputs.file_path != '' && steps.authorize_commenter.outcome == 'success' && steps.branch_and_copy.outputs.NO_CHANGES != 'true' && steps.branch_and_copy.outputs.APPLY_FAILED != 'true' && steps.validate_cpr_inputs.outcome == 'success'
        id: cpr
        uses: peter-evans/create-pull-request@98357b18bf14b5342f975ff684046ec3b2a07725 #v8.0.0
        with:
          committer: ${{ steps.bridge.outputs.committer }}
          author: ${{ steps.bridge.outputs.author }}
          path: base
          base: ${{ steps.bridge.outputs.base_ref }}
          token: ${{ secrets.token || steps.token_from_app.outputs.token || github.token }}
          # Fork-only options: when push_to_fork is empty, these resolve to empty strings and CPR uses base-repo branch mode.
          branch-token: ${{ inputs.push_to_fork != '' && (secrets.branch_token || steps.branch_token_from_app.outputs.token || secrets.token || steps.token_from_app.outputs.token || github.token) || '' }}
          push-to-fork: ${{ inputs.push_to_fork != '' && inputs.push_to_fork || '' }}
          # CPR expects a strict boolean; treat any non-"true" value as false.
          maintainer-can-modify: ${{ inputs.maintainer_can_modify == 'true' }}
          commit-message: "Automated addition of changes in ${{ steps.bridge.outputs.file_path }}"
          title: "chore(${{ steps.bridge.outputs.file_path }}): automated extraction"
          body: "This PR was automatically created from a review comment on PR #${{ steps.bridge.outputs.pr_number }}."
          branch: ${{ steps.branch_and_copy.outputs.BRANCH }}
          branch-suffix: random
          delete-branch: true

      - name: Comment back on the original PR
        if: always() && steps.bridge.outputs.pr_number != ''
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          AUTHZ_OUTCOME: ${{ steps.authorize_commenter.outcome }}
          AUTHZ_DECISION: ${{ steps.authorize_commenter.outputs.authz_decision }}
          AUTHZ_REASON: ${{ steps.authorize_commenter.outputs.authz_reason }}
          AUTHZ_DETAILS: ${{ steps.authorize_commenter.outputs.authz_details }}
          AUTHZ_TOKEN_SOURCE: ${{ steps.authorize_commenter.outputs.authz_token_source }}
        with:
          script: |
            const originalPrNumber = Number('${{ steps.bridge.outputs.pr_number }}');
            const reviewCommentId = Number('${{ steps.bridge.outputs.review_comment_id }}');
            const repoFull = '${{ steps.bridge.outputs.base_repo }}';
            const [owner, repo] = repoFull.split('/');
            const filePath = '${{ steps.bridge.outputs.file_path }}';
            const applyFailed = '${{ steps.branch_and_copy.outputs.APPLY_FAILED }}' === 'true';
            const noChanges = '${{ steps.branch_and_copy.outputs.NO_CHANGES }}' === 'true';
            const automatedPrNumber = '${{ steps.cpr.outputs.pull-request-number }}';
            const baseRef = '${{ steps.bridge.outputs.base_ref }}';
            const headRef = '${{ steps.bridge.outputs.head_ref }}';
            const headLabel = '${{ steps.bridge.outputs.head_label }}';
            const sourceBranch = headLabel || headRef;
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}/attempts/${process.env.GITHUB_RUN_ATTEMPT}`;
            const tokenSource = '${{ steps.token_mode.outputs.token_source }}';
            const branchTokenSource = '${{ steps.token_mode.outputs.branch_token_source }}';
            const authzOutcome = process.env.AUTHZ_OUTCOME || '';
            const authzDecision = process.env.AUTHZ_DECISION || '';
            const authzReason = process.env.AUTHZ_REASON || '';
            const authzDetails = process.env.AUTHZ_DETAILS || '';
            const authzTokenSource = process.env.AUTHZ_TOKEN_SOURCE || 'unknown';
            const forkOwner = '${{ steps.fork_owner.outputs.fork_owner }}';
            const forkOwnerType = '${{ steps.fork_owner.outputs.fork_owner_type }}';

            if (!Number.isFinite(originalPrNumber) || originalPrNumber <= 0) {
              core.info('Missing or invalid original PR number; cannot post a callback comment.');
              return;
            }

            if (!owner || !repo) {
              core.info(`Missing repository context (${repoFull}); cannot post a callback comment.`);
              return;
            }

            const outcomes = [
              ['Consume bridge artifact', '${{ steps.bridge.outcome }}'],
              ['Check out BASE', '${{ steps.checkout_base.outcome }}'],
              ['Check out HEAD', '${{ steps.checkout_head.outcome }}'],
              ['Authorize commenter', '${{ steps.authorize_commenter.outcome }}'],
              ['Stage file changes', '${{ steps.branch_and_copy.outcome }}'],
              ['Detect push_to_fork owner type', '${{ steps.fork_owner.outcome }}'],
              ['Validate create-pull-request inputs', '${{ steps.validate_cpr_inputs.outcome }}'],
              ['Create Pull Request', '${{ steps.cpr.outcome }}'],
            ];
            const failedStepNames = outcomes
              .filter(([, outcome]) => outcome === 'failure' || outcome === 'cancelled')
              .map(([name]) => name);
            const outcomeLines = outcomes
              .filter(([, outcome]) => outcome)
              .map(([name, outcome]) => `- ${name}: \`${outcome}\``)
              .join('\n');

            let title = 'Splice bot status';
            let adviceLines = [];
            let bodyIntro = '';

            if (!filePath) {
              title = 'Could not determine target file';
              bodyIntro = 'I could not determine `event.comment.path` from the bridge artifact.';
              adviceLines = [
                'Ensure the source workflow uploaded the `workflow-data` artifact and this run was triggered from a `pull_request_review_comment` event.',
                'Check the run logs link below and re-run after posting a fresh review comment on a file line.',
              ];
            } else if (authzOutcome === 'failure' || authzDecision === 'deny') {
              title = 'Not authorized to trigger splice-bot';
              bodyIntro = authzReason
                ? authzReason
                : 'This review comment is not authorized by the configured splice-bot trigger policy.';
              adviceLines = [
                'If this should be allowed, update workflow inputs (`allow_pr_author`, `min_repo_permission`, `allowed_users`, `allowed_teams`) or adjust repository/team permissions.',
                'You can also re-run using an authorized commenter account.',
              ];
            } else if (authzDecision === 'error') {
              title = 'Authorization check failed';
              bodyIntro = authzReason
                ? authzReason
                : 'I could not complete the authorization checks for this review comment.';
              adviceLines = [
                'Verify the auth-check token has required access for collaborator/team lookups (`authz_token` preferred).',
                'Check run logs and retry once token permissions are fixed.',
              ];
            } else if (applyFailed) {
              title = 'Could not apply patch cleanly';
              bodyIntro = `I couldn't cleanly apply the changes for **${filePath}** onto the latest base branch (**${baseRef}**).`;
              adviceLines = [
                `Rebase the source branch (**${sourceBranch}**) onto **${baseRef}**, or merge **${baseRef}** into **${sourceBranch}**.`,
                'Resolve conflicts in that file, push, then trigger the bot again with a new review comment.',
              ];
            } else if (noChanges) {
              title = 'No file changes found';
              bodyIntro = `I found no diff for **${filePath}** between the PR head and merge base, so there was nothing to split into a new PR.`;
              adviceLines = [
                'Confirm the review comment is on a file that actually changed in the current PR head commit range.',
                'Push the intended file changes first, then trigger the bot again with a new review comment.',
              ];
            } else if (automatedPrNumber) {
              title = 'Split PR created';
              bodyIntro = `Split off the changes to **${filePath}** in #${automatedPrNumber}.`;
              adviceLines = [
                `Review and merge #${automatedPrNumber} if it looks correct.`,
              ];
            } else {
              title = 'Failed to create split PR';
              bodyIntro = filePath
                ? `I couldn't create a split PR for **${filePath}**.`
                : "I couldn't create a split PR.";
              adviceLines = [];
              if (failedStepNames.includes('Consume bridge artifact')) {
                adviceLines.push('Ensure the source workflow uploaded `workflow-data` and this workflow is consuming the correct `source_workflow`.');
              }
              if (failedStepNames.includes('Check out BASE') || failedStepNames.includes('Check out HEAD')) {
                adviceLines.push('Verify the token used by checkout can read both base/head repos and that the referenced refs/SHAs still exist.');
              }
              if (failedStepNames.includes('Stage file changes')) {
                adviceLines.push('Inspect the "Stage file changes" logs for git fetch/apply errors and retry after rebasing if needed.');
              }
              if (failedStepNames.includes('Detect push_to_fork owner type')) {
                adviceLines.push('Verify that `push_to_fork` refers to an existing fork owner and that the workflow token can query repository/user metadata.');
              }
              if (failedStepNames.includes('Validate create-pull-request inputs')) {
                adviceLines.push('Fix invalid `create-pull-request` inputs reported in the validation step logs (for example `push_to_fork`, `maintainer_can_modify`, author/committer format, or generated branch name).');
              }
              if (failedStepNames.includes('Create Pull Request')) {
                adviceLines.push('Check the "Create Pull Request" logs for input validation errors (for example invalid `maintainer-can-modify` values) and other action-level failures.');
                adviceLines.push('Verify fork settings and branch inputs (`push_to_fork`, branch naming, and whether the target branch already exists) are valid for this repository.');
                adviceLines.push('Also verify token permissions include `contents: write` and `pull-requests: write`; in fork mode, ensure branch token can push to the fork.');
              }
              if (adviceLines.length === 0) {
                adviceLines.push('Open the run logs and retry after fixing the reported step failure.');
              }
            }

            const failedStepsLine = failedStepNames.length > 0
              ? `\n\nFailed step(s): ${failedStepNames.join(', ')}.`
              : '';
            const adviceBlock = adviceLines.map((line) => `- ${line}`).join('\n');
            const tokenDiagnostics = [
              `- token source: \`${tokenSource || 'unknown'}\``,
              `- branch token source: \`${branchTokenSource || 'unknown'}\``,
              `- authz token source: \`${authzTokenSource || 'unknown'}\``,
            ];
            if (forkOwner || forkOwnerType) {
              tokenDiagnostics.push(`- push_to_fork owner: \`${forkOwner || 'unknown'}\` (type: \`${forkOwnerType || 'unknown'}\`)`);
            }
            if (authzDetails) {
              const detailLines = authzDetails
                .split('\n')
                .filter(Boolean)
                .map((line) => `- ${line}`);
              if (detailLines.length > 0) {
                tokenDiagnostics.push(...detailLines);
              }
            }
            const tokenDiagnosticsBlock = tokenDiagnostics.join('\n');
            const stepOutcomesDetails = `<details>\n<summary>Step outcomes</summary>\n\n${outcomeLines}\n</details>`;
            const successBody = `**${title}**\n\n${bodyIntro}`;
            const failureBody = `**${title}**\n\n${bodyIntro}${failedStepsLine}\n\nAdvice:\n${adviceBlock}\n\nToken diagnostics:\n${tokenDiagnosticsBlock}\n\nRun logs: ${runUrl}\n\n${stepOutcomesDetails}`;
            const body = automatedPrNumber ? successBody : failureBody;

            try {
              if (Number.isFinite(reviewCommentId) && reviewCommentId > 0) {
                await github.rest.pulls.createReplyForReviewComment({
                  owner,
                  repo,
                  pull_number: originalPrNumber,
                  comment_id: reviewCommentId,
                  body,
                });
                return;
              }
            } catch (replyError) {
              core.warning(`Unable to reply to review comment ${reviewCommentId}: ${replyError.message}`);
            }

            await github.rest.issues.createComment({ owner, repo, issue_number: originalPrNumber, body });
